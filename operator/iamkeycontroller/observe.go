package iamkeycontroller

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"reflect"

	pipeline "github.com/ccremer/go-command-pipeline"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	exoscalesdk "github.com/exoscale/egoscale/v2"
	exooapi "github.com/exoscale/egoscale/v2/oapi"
	exoscalev1 "github.com/vshn/provider-exoscale/apis/exoscale/v1"
	"github.com/vshn/provider-exoscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	controllerruntime "sigs.k8s.io/controller-runtime"
)

// Observe implements managed.ExternalClient.
func (p *IAMKeyPipeline) Observe(ctx context.Context, mg resource.Managed) (managed.ExternalObservation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.V(1).Info("Observing resource")

	iamKey := fromManaged(mg)
	// to manage state of new and old keys I need other variable, this is why this annotation is set
	// otherwise observation fails for one of key types
	if _, exists := iamKey.Annotations["newKeyType"]; exists {
		if iamKey.Status.AtProvider.RoleID == "" {
			// get the data generated by Create() via annotations, since in Create() we're not allowed to update the status.
			if RoleID, exists := iamKey.Annotations[RoleIDAnnotationKey]; exists {
				iamKey.Status.AtProvider.RoleID = RoleID
				delete(iamKey.Annotations, RoleIDAnnotationKey)
				log.V(1).Info("Deleting annotation", "key", RoleIDAnnotationKey)
			} else {
				// New resource, create user first
				log.V(1).Info("IAM Role not found, returning")
				return managed.ExternalObservation{}, nil
			}
		}
	}
	if iamKey.Status.AtProvider.KeyID == "" {
		// get the data generated by Create() via annotations, since in Create() we're not allowed to update the status.
		if KeyId, exists := iamKey.Annotations[KeyIDAnnotationKey]; exists {
			iamKey.Status.AtProvider.KeyID = KeyId
			delete(iamKey.Annotations, KeyIDAnnotationKey)
			log.V(1).Info("Deleting annotation", "key", KeyIDAnnotationKey)
		} else {
			// New resource, create user first
			log.V(1).Info("IAM key not found, returning")
			return managed.ExternalObservation{}, nil
		}
	}

	pctx := &pipelineContext{Context: ctx, iamKey: iamKey}

	// since new create() adds RoleID annotation it's enough to just check whether it exists
	if iamKey.Status.AtProvider.RoleID != "" {
		err := p.getIAMKey(pctx)
		if err != nil {
			if iamKey.GetDeletionTimestamp() != nil {
				return managed.ExternalObservation{ResourceExists: false}, nil
			}
			return managed.ExternalObservation{ResourceExists: false}, err
		}
	} else {
		err := p.getLegacyIAMKey(pctx)
		if err != nil {
			return managed.ExternalObservation{}, resource.Ignore(isNotFound, err)
		}
	}

	pipe := pipeline.NewPipeline[*pipelineContext]()
	err := pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).
		WithSteps(
			pipe.NewStep("fetch credentials secret", p.fetchCredentialsSecret),
			pipe.NewStep("check credentials", p.checkSecret),
			pipe.NewStep("check if role is up to date", p.isRoleUptodate),
		).RunWithContext(pctx)

	if err != nil {
		log.V(2).Info("pipeline that fetches and checks credentials secret returned", "error", err)
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false}, nil
	}

	iamKey.Status.AtProvider.KeyName = *pctx.iamExoscaleKey.Name

	if iamKey.Status.AtProvider.RoleID == "" {
		iamKey.Status.AtProvider.ServicesSpec.SOS.Buckets = getBuckets(*pctx.iamExoscaleKey.Resources)
	} else {
		iamKey.Status.AtProvider.ServicesSpec.SOS.Buckets = iamKey.Spec.ForProvider.Services.SOS.Buckets
	}

	connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
	if err != nil {
		return managed.ExternalObservation{}, fmt.Errorf("cannot parse connection details: %w", err)
	}
	log.Info("Observation successfull", "keyName", iamKey.Status.AtProvider.KeyName)
	iamKey.SetConditions(xpv1.Available())
	return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: true, ConnectionDetails: connDetails}, nil
}

// getIAMKey fetches an existing IAM key from the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) getIAMKey(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)
	keyDetails := exooapi.IamApiKey{}

	// send request
	resp, err := executeRequest(ctx, "GET", ctx.iamKey.Spec.ForProvider.Zone, "/v2/api-key/"+ctx.iamKey.Status.AtProvider.KeyID, p.apiKey, p.apiSecret, nil)
	if err != nil {
		return err
	}

	err = json.NewDecoder(resp.Body).Decode(&keyDetails)
	if err != nil {
		log.Error(err, "Cannot decode response body (IamKeyGet)")
		return err
	}

	ctx.iamExoscaleKey = &exoscalesdk.IAMAccessKey{
		Key:  keyDetails.Key,
		Name: keyDetails.Name,
	}

	log.Info("IAM key fetched successfully", "keyName", ctx.iamKey.Spec.ForProvider.KeyName, "response", resp.Status)

	return nil

}

// getIAMKey fetches an existing IAM key from the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) getLegacyIAMKey(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)

	exoscaleIAMKey, err := p.exoscaleClient.GetIAMAccessKey(ctx, ctx.iamKey.Spec.ForProvider.Zone, ctx.iamKey.Status.AtProvider.KeyID)
	if err != nil {
		return err
	}
	ctx.iamExoscaleKey = exoscaleIAMKey
	log.V(1).Info("Fetched IAM key in exoscale", "iamID", exoscaleIAMKey.Key, "keyName", exoscaleIAMKey.Name)
	return nil

}

func (p *IAMKeyPipeline) fetchCredentialsSecret(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)
	secretRef := ctx.iamKey.Spec.WriteConnectionSecretToReference
	ctx.credentialsSecret = &corev1.Secret{}
	log.Info("Fetching credentials secret during iamkey observation", secretRef.Namespace, secretRef.Name)
	err := p.kube.Get(ctx, types.NamespacedName{Namespace: secretRef.Namespace, Name: secretRef.Name}, ctx.credentialsSecret)
	if err != nil {
		log.Error(err, "Cannot fetch credentials secret")
		return err
	}
	return nil

}

func (p *IAMKeyPipeline) checkSecret(ctx *pipelineContext) error {
	data := ctx.credentialsSecret.Data
	if len(data) == 0 {
		return fmt.Errorf("secret %q does not have any data", fmt.Sprintf("%s/%s", ctx.credentialsSecret.Namespace, ctx.credentialsSecret.Name))
	}
	// Populate secret key from the secret credentials as exoscale IAM get operation does not return the secret key
	secret := string(data[exoscalev1.SecretAccessKeyName])
	ctx.iamExoscaleKey.Secret = &secret
	return nil
}

func getBuckets(iamResources []exoscalesdk.IAMAccessKeyResource) []string {
	buckets := make([]string, 0, len(iamResources))
	if len(iamResources) == 0 {
		return buckets
	}
	for _, iamResource := range iamResources {
		if iamResource.Domain == SOSResourceDomain {
			buckets = append(buckets, iamResource.ResourceName)
		}
	}
	return buckets
}

func isNotFound(err error) bool {
	var errResp *url.Error
	if errors.As(err, &errResp) {
		return err.(*url.Error).Err.Error() == "resource not found"
	}
	return false
}

func (p *IAMKeyPipeline) isRoleUptodate(ctx *pipelineContext) error {

	// Only new keys support the roles. We don't handle legacy keys.
	if _, exists := ctx.iamKey.Annotations["newKeyType"]; !exists {
		return nil
	}

	errNotUpToDate := fmt.Errorf("roles are not equal, IAM Key is not up to date")

	obsRole, err := p.observeRole(ctx)
	if err != nil {
		return errNotUpToDate
	}

	desiredRole := createRole(ctx.iamKey.Spec.ForProvider.KeyName, ctx.iamKey.Spec.ForProvider.Services.SOS.Buckets)

	// We're only interested in the policy as most fields in the role can't be
	// changed anyway after creation.
	if !reflect.DeepEqual(obsRole.Policy, desiredRole.Policy) {
		return errNotUpToDate
	}

	return nil
}

func (p *IAMKeyPipeline) observeRole(ctx *pipelineContext) (*exooapi.IamRole, error) {

	resp, err := executeRequest(ctx, "GET", ctx.iamKey.Spec.ForProvider.Zone, "/v2/iam-role/"+ctx.iamKey.Status.AtProvider.RoleID, p.apiKey, p.apiSecret, nil)
	if err != nil {
		return nil, err
	}

	defer func() { _ = resp.Body.Close() }()

	respRole := &exooapi.IamRole{}
	err = json.NewDecoder(resp.Body).Decode(respRole)
	if err != nil {
		return nil, err
	}

	return respRole, nil
}
