package iamkeycontroller

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	pipeline "github.com/ccremer/go-command-pipeline"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/event"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	exoscalesdk "github.com/exoscale/egoscale/v2"
	exooapi "github.com/exoscale/egoscale/v2/oapi"
	exoscalev1 "github.com/vshn/provider-exoscale/apis/exoscale/v1"

	"github.com/vshn/provider-exoscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"

	"k8s.io/utils/ptr"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// Create implements managed.ExternalClient.
func (p *IAMKeyPipeline) Create(ctx context.Context, mg resource.Managed) (managed.ExternalCreation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("Creating resource")

	iam := fromManaged(mg)
	iam.SetConditions(xpv1.Creating())
	if iam.Status.AtProvider.KeyID != "" {
		// IAMKey already exists
		log.Info("IAM Key already exists", "keyID", iam.Status.AtProvider.KeyID)
		return managed.ExternalCreation{}, nil
	}

	pctx := &pipelineContext{Context: ctx, iamKey: iam}
	pipe := pipeline.NewPipeline[*pipelineContext]()
	pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).
		WithSteps(
			pipe.NewStep("create IAM key", p.createIAMKey),
			pipe.NewStep("create credentials secret", p.createCredentialsSecret),
			pipe.NewStep("emit event", p.emitCreationEvent),
		)
	err := pipe.RunWithContext(pctx)
	if err != nil {
		log.Error(err, "Cannot create IAM Key")
		return managed.ExternalCreation{}, errors.Wrap(err, "cannot create IAM Key")
	}
	connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
	if err != nil {
		log.Error(err, "Cannot parse connection details")
		return managed.ExternalCreation{}, fmt.Errorf("cannot parse connection details: %w", err)
	}

	return managed.ExternalCreation{ConnectionDetails: connDetails}, nil
}

// createIAMKey creates a new IAMKey in the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) createIAMKey(ctx *pipelineContext) error {

	iamKey := ctx.iamKey
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("starting creation")

	log.Info("IAM Role doesnt exists, creating", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	autogeneratedAppcatRole := createRole(iamKey.Spec.ForProvider.KeyName, iamKey.Spec.ForProvider.Services.SOS.Buckets)

	// send request
	resp, err := executeRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/iam-role", p.apiKey, p.apiSecret, autogeneratedAppcatRole)
	if err != nil {
		return err
	}

	iamRole := exooapi.Operation{}

	// unmarshall response to iamRoles
	err = json.NewDecoder(resp.Body).Decode(&iamRole)
	if err != nil {
		log.Error(err, "Cannot unmarshall response to iamRolesResponse")
		return err
	}

	iamRoleID := *iamRole.Reference.Id
	log.Info("IAM Role created", "iamRoleID", iamRoleID)

	log.Info("IAM Key doesnt exists, creating", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	newIamKey := exooapi.IamApiKey{
		RoleId: &iamRoleID,
		Name:   &ctx.iamKey.Spec.ForProvider.KeyName,
	}

	// since their API is async and it needs a moment to create the IAM Role, we need to wait for it
	for i := 0; i < 10; i++ {
		// send request
		resp, err = executeRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/api-key", p.apiKey, p.apiSecret, newIamKey)
		if err != nil {
			time.Sleep(time.Millisecond * 500)
			continue
		}
		break
	}

	if err != nil {
		return err
	}

	iamKeyCreated := exooapi.IamApiKeyCreated{}

	// unmarshall response to iamRoles
	err = json.NewDecoder(resp.Body).Decode(&iamKeyCreated)
	if err != nil {
		return err
	}

	ctx.iamExoscaleKey = &exoscalesdk.IAMAccessKey{
		Key:    iamKeyCreated.Key,
		Name:   iamKeyCreated.Name,
		Secret: iamKeyCreated.Secret,
	}

	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, KeyIDAnnotationKey, *ctx.iamExoscaleKey.Key)
	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, RoleIDAnnotationKey, iamRoleID)
	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, "newKeyType", "true")
	log.Info("IAM Key created", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	defer resp.Body.Close()
	return nil
}

func (p *IAMKeyPipeline) emitCreationEvent(ctx *pipelineContext) error {
	p.recorder.Event(ctx.iamKey, event.Event{
		Type:    event.TypeNormal,
		Reason:  "Created",
		Message: "IAMKey successfully created",
	})
	return nil
}

// createCredentialsSecret creates the secret with AIMKey's S3 credentials.
func (p *IAMKeyPipeline) createCredentialsSecret(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)
	secretRef := ctx.iamKey.Spec.WriteConnectionSecretToReference

	ctx.credentialsSecret = &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: secretRef.Name, Namespace: secretRef.Namespace}}

	_, err := controllerruntime.CreateOrUpdate(ctx, p.kube, ctx.credentialsSecret, func() error {
		secret := ctx.credentialsSecret
		secret.Labels = labels.Merge(secret.Labels, getCommonLabels(ctx.iamKey.Name))
		if secret.Data == nil {
			secret.Data = map[string][]byte{}
		}
		connDetails, err := toConnectionDetails(ctx.iamExoscaleKey)
		if err != nil {
			return fmt.Errorf("cannot parse connection details: %w", err)
		}
		for k, v := range connDetails {
			secret.Data[k] = v
		}
		secret.Immutable = ptr.To[bool](true)

		err = controllerutil.SetOwnerReference(ctx.iamKey, secret, p.kube.Scheme())
		if err != nil {

			log.Error(err, "Cannot set owner reference")
			return err
		}
		return nil
	})
	if err != nil {
		log.Error(err, "Cannot create credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name), "secretData", ctx.credentialsSecret.Data, "secretLabels", ctx.credentialsSecret.Labels)
		return err
	}
	log.V(1).Info("Created credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
	return nil

}

func getCommonLabels(instanceName string) labels.Set {
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/
	return labels.Set{
		"app.kubernetes.io/instance":   instanceName,
		"app.kubernetes.io/managed-by": exoscalev1.Group,
		"app.kubernetes.io/created-by": fmt.Sprintf("controller-%s", strings.ToLower(exoscalev1.IAMKeyKind)),
	}
}
