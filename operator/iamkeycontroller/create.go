package iamkeycontroller

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	pipeline "github.com/ccremer/go-command-pipeline"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/event"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	exoscalesdk "github.com/exoscale/egoscale/v2"
	exooapi "github.com/exoscale/egoscale/v2/oapi"
	exoscalev1 "github.com/vshn/provider-exoscale/apis/exoscale/v1"
	"github.com/vshn/provider-exoscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"

	"k8s.io/utils/pointer"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// Create implements managed.ExternalClient.
func (p *IAMKeyPipeline) Create(ctx context.Context, mg resource.Managed) (managed.ExternalCreation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("Creating resource")

	iam := fromManaged(mg)
	if iam.Status.AtProvider.KeyID != "" {
		// IAMKey already exists
		log.Info("IAM Key already exists", "keyID", iam.Status.AtProvider.KeyID)
		return managed.ExternalCreation{}, nil
	}

	pctx := &pipelineContext{Context: ctx, iamKey: iam}
	pipe := pipeline.NewPipeline[*pipelineContext]()
	pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).
		WithSteps(
			pipe.NewStep("create IAM key", p.createIAMKey),
			pipe.NewStep("create credentials secret", p.createCredentialsSecret),
			//pipe.NewStep("emit event", p.emitCreationEvent),
		)
	err := pipe.RunWithContext(pctx)
	if err != nil {
		log.Error(err, "Cannot create IAM Key")
		return managed.ExternalCreation{}, errors.Wrap(err, "cannot create IAM Key")
	}
	connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
	if err != nil {
		log.Error(err, "Cannot parse connection details")
		return managed.ExternalCreation{}, fmt.Errorf("cannot parse connection details: %w", err)
	}

	return managed.ExternalCreation{ConnectionDetails: connDetails}, nil
}

// createIAMKey creates a new IAMKey in the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) createIAMKey(ctx *pipelineContext) error {
	iamRoleID := ""
	iamRoleNameFound := false

	iamKeyFound := false

	iamKey := ctx.iamKey
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("starting creation")
	var keyResources []exoscalesdk.IAMAccessKeyResource
	for _, bucket := range iamKey.Spec.ForProvider.Services.SOS.Buckets {
		keyResource := exoscalesdk.IAMAccessKeyResource{
			Domain:       SOSResourceDomain,
			ResourceName: bucket,
			ResourceType: BucketResourceType,
		}
		keyResources = append(keyResources, keyResource)
	}

	// send request
	resp, err := ExecuteRequest(ctx, "GET", ctx.iamKey.Spec.ForProvider.Zone, "/v2/iam-role", nil)
	if err != nil {
		return err
	}

	//iamRoles := GETv3IAMRoleResponse{}

	iamRoles := IamRolesList{}
	// unmarshall response to iamRoles

	err = json.NewDecoder(resp.Body).Decode(&iamRoles)
	if err != nil {
		log.Error(err, "Cannot unmarshall response to iamRoles")
		return err
	}

	for _, val := range iamRoles.IamRoles {
		if *val.Name == IamRoleName {
			iamRoleNameFound = true
			iamRoleID = *val.Id
		}
	}
	// check if iam role exists if not create it
	if !iamRoleNameFound {
		autogeneratedAppcatRole := &exooapi.IamRole{
			Name:        &IamRoleName,
			Description: pointer.String("IAM Role for SOS+IAM creation, it was autogenerated by Appcat operator"),
			Permissions: &[]exooapi.IamRolePermissions{
				exooapi.IamRolePermissionsBypassGovernanceRetention,
			},
			Editable: pointer.Bool(true),
			Policy: &exooapi.IamPolicy{
				DefaultServiceStrategy: exooapi.IamPolicyDefaultServiceStrategyAllow,
				Services: exooapi.IamPolicy_Services{
					AdditionalProperties: map[string]exooapi.IamServicePolicy{
						"sos": {
							Type: (*exooapi.IamServicePolicyType)(pointer.String("allow")),
						},
						"iam": {
							Type: (*exooapi.IamServicePolicyType)(pointer.String("allow")),
						},
					},
				},
			},
		}

		// send request
		resp, err = ExecuteRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/iam-role", autogeneratedAppcatRole)
		if err != nil {
			return err
		}

		iamRole := exooapi.Operation{}

		// unmarshall response to iamRoles
		err = json.NewDecoder(resp.Body).Decode(&iamRole)
		if err != nil {
			log.Error(err, "Cannot unmarshall response to iamRolesResponse")
			return err
		}
		iamRoleID = *iamRole.Id
		log.Info("IAM Role created", "iamRoleID", iamRoleID)
	}

	// get IAMKey

	keyList := IamKeysList{}

	// send request
	resp, err = ExecuteRequest(ctx, "GET", ctx.iamKey.Spec.ForProvider.Zone, "/v2/api-key", nil)
	if err != nil {
		log.Error(err, "Cannot list apiKeys")
		return err
	}

	err = json.NewDecoder(resp.Body).Decode(&keyList)
	if err != nil {
		log.Error(err, "Cannot unmarshall response to keyList")
		return err
	}

	for _, val := range keyList.IamKeys {
		if val.Name == &ctx.iamKey.Spec.ForProvider.KeyName {
			iamKeyFound = true
			log.Info("IAM Key already exists", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
		}
	}

	// check if iam key exists if not create it
	if !iamKeyFound {
		log.Info("IAM Key doesnt exists, creating", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
		newIamKey := exooapi.IamApiKey{
			RoleId: &iamRoleID,
			Name:   &ctx.iamKey.Spec.ForProvider.KeyName,
		}

		// send request
		resp, err = ExecuteRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/api-key", newIamKey)
		if err != nil {
			return err
		}

		iamKey := exooapi.IamApiKeyCreated{}

		// unmarshall response to iamRoles
		err = json.NewDecoder(resp.Body).Decode(&iamKey)
		if err != nil {
			return err
		}

		ctx.iamExoscaleKey = &exoscalesdk.IAMAccessKey{
			Key:    iamKey.Key,
			Name:   iamKey.Name,
			Secret: iamKey.Secret,
		}

		log.Info("IAM Key created", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
		metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, KeyIDAnnotationKey, *iamKey.Key)
	}
	defer resp.Body.Close()
	return nil
}

func (p *IAMKeyPipeline) emitCreationEvent(ctx *pipelineContext) error {
	p.recorder.Event(ctx.iamKey, event.Event{
		Type:    event.TypeNormal,
		Reason:  "Created",
		Message: "IAMKey successfully created",
	})
	return nil
}

// createCredentialsSecret creates the secret with AIMKey's S3 credentials.
func (p *IAMKeyPipeline) createCredentialsSecret(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)
	secretRef := ctx.iamKey.Spec.WriteConnectionSecretToReference

	ctx.credentialsSecret = &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: secretRef.Name, Namespace: secretRef.Namespace}}

	_, err := controllerruntime.CreateOrUpdate(ctx, p.kube, ctx.credentialsSecret, func() error {
		secret := ctx.credentialsSecret
		secret.Labels = labels.Merge(secret.Labels, getCommonLabels(ctx.iamKey.Name))
		if secret.Data == nil {
			secret.Data = map[string][]byte{}
		}
		connDetails, err := toConnectionDetails(ctx.iamExoscaleKey)
		if err != nil {
			return fmt.Errorf("cannot parse connection details: %w", err)
		}
		for k, v := range connDetails {
			secret.Data[k] = v
		}
		secret.Immutable = pointer.Bool(true)

		err = controllerutil.SetOwnerReference(ctx.iamKey, secret, p.kube.Scheme())
		if err != nil {

			log.Error(err, "Cannot set owner reference")
			return err
		}
		return nil
	})
	if err != nil {
		log.Error(err, "Cannot create credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name), "secretData", ctx.credentialsSecret.Data, "secretLabels", ctx.credentialsSecret.Labels)
		return err
	}
	log.V(1).Info("Created credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
	return nil

}

func getCommonLabels(instanceName string) labels.Set {
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/
	return labels.Set{
		"app.kubernetes.io/instance":   instanceName,
		"app.kubernetes.io/managed-by": exoscalev1.Group,
		"app.kubernetes.io/created-by": fmt.Sprintf("controller-%s", strings.ToLower(exoscalev1.IAMKeyKind)),
	}
}
