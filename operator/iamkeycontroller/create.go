package iamkeycontroller

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	pipeline "github.com/ccremer/go-command-pipeline"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/event"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	exoscalesdk "github.com/exoscale/egoscale/v2"
	exooapi "github.com/exoscale/egoscale/v2/oapi"
	exoscalev1 "github.com/vshn/provider-exoscale/apis/exoscale/v1"

	"github.com/vshn/provider-exoscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"

	"k8s.io/utils/pointer"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// Create implements managed.ExternalClient.
func (p *IAMKeyPipeline) Create(ctx context.Context, mg resource.Managed) (managed.ExternalCreation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("Creating resource")

	iam := fromManaged(mg)
	iam.SetConditions(xpv1.Creating())
	if iam.Status.AtProvider.KeyID != "" {
		// IAMKey already exists
		log.Info("IAM Key already exists", "keyID", iam.Status.AtProvider.KeyID)
		return managed.ExternalCreation{}, nil
	}

	pctx := &pipelineContext{Context: ctx, iamKey: iam}
	pipe := pipeline.NewPipeline[*pipelineContext]()
	pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).
		WithSteps(
			pipe.NewStep("create IAM key", p.createIAMKey),
			pipe.NewStep("create credentials secret", p.createCredentialsSecret),
			pipe.NewStep("emit event", p.emitCreationEvent),
		)
	err := pipe.RunWithContext(pctx)
	if err != nil {
		log.Error(err, "Cannot create IAM Key")
		return managed.ExternalCreation{}, errors.Wrap(err, "cannot create IAM Key")
	}
	connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
	if err != nil {
		log.Error(err, "Cannot parse connection details")
		return managed.ExternalCreation{}, fmt.Errorf("cannot parse connection details: %w", err)
	}

	return managed.ExternalCreation{ConnectionDetails: connDetails}, nil
}

// createIAMKey creates a new IAMKey in the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) createIAMKey(ctx *pipelineContext) error {

	iamKey := ctx.iamKey
	log := controllerruntime.LoggerFrom(ctx)
	log.Info("starting creation")

	policyAllow := exooapi.IamServicePolicyRuleActionAllow
	policyDeny := exooapi.IamServicePolicyRuleActionDeny
	policyRules := exooapi.IamServicePolicyTypeRules

	log.Info("IAM Role doesnt exists, creating", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	autogeneratedAppcatRole := &exooapi.IamRole{
		Name:        &iamKey.Spec.ForProvider.KeyName,
		Description: pointer.String("IAM Role for SOS+IAM creation, it was autogenerated by provider-exoscale"),
		Permissions: &[]exooapi.IamRolePermissions{
			exooapi.IamRolePermissionsBypassGovernanceRetention,
		},
		Editable: pointer.Bool(true),
		Policy: &exooapi.IamPolicy{
			DefaultServiceStrategy: exooapi.IamPolicyDefaultServiceStrategyDeny,
			Services: exooapi.IamPolicy_Services{
				AdditionalProperties: map[string]exooapi.IamServicePolicy{
					"sos": {
						Type:  &policyRules,
						Rules: &[]exooapi.IamServicePolicyRule{},
					},
				},
			},
		},
	}
	// we must first add buckets to deny list and then add the allow rule, otherwise it will not work
	for _, bucket := range iamKey.Spec.ForProvider.Services.SOS.Buckets {
		*autogeneratedAppcatRole.Policy.Services.AdditionalProperties["sos"].Rules = append(*autogeneratedAppcatRole.Policy.Services.AdditionalProperties["sos"].Rules, exooapi.IamServicePolicyRule{
			Action:     &policyDeny,
			Expression: pointer.String("resources.bucket != " + "'" + bucket + "'"),
		})
	}

	*autogeneratedAppcatRole.Policy.Services.AdditionalProperties["sos"].Rules = append(*autogeneratedAppcatRole.Policy.Services.AdditionalProperties["sos"].Rules, exooapi.IamServicePolicyRule{
		Action:     &policyAllow,
		Expression: pointer.String("true"),
	})

	// send request
	resp, err := ExecuteRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/iam-role", p.apiKey, p.apiSecret, autogeneratedAppcatRole)
	if err != nil {
		return err
	}

	iamRole := exooapi.Operation{}

	// unmarshall response to iamRoles
	err = json.NewDecoder(resp.Body).Decode(&iamRole)
	if err != nil {
		log.Error(err, "Cannot unmarshall response to iamRolesResponse")
		return err
	}

	iamRoleID := *iamRole.Reference.Id
	log.Info("IAM Role created", "iamRoleID", iamRoleID)

	log.Info("IAM Key doesnt exists, creating", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	newIamKey := exooapi.IamApiKey{
		RoleId: &iamRoleID,
		Name:   &ctx.iamKey.Spec.ForProvider.KeyName,
	}

	// since their API is async and it needs a moment to create the IAM Role, we need to wait for it
	for i := 0; i < 10; i++ {
		// send request
		resp, err = ExecuteRequest(ctx, "POST", ctx.iamKey.Spec.ForProvider.Zone, "/v2/api-key", p.apiKey, p.apiSecret, newIamKey)
		if err != nil {
			time.Sleep(time.Millisecond * 500)
			continue
		}
		break
	}

	if err != nil {
		return err
	}

	iamKeyCreated := exooapi.IamApiKeyCreated{}

	// unmarshall response to iamRoles
	err = json.NewDecoder(resp.Body).Decode(&iamKeyCreated)
	if err != nil {
		return err
	}

	ctx.iamExoscaleKey = &exoscalesdk.IAMAccessKey{
		Key:    iamKeyCreated.Key,
		Name:   iamKeyCreated.Name,
		Secret: iamKeyCreated.Secret,
	}

	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, KeyIDAnnotationKey, *ctx.iamExoscaleKey.Key)
	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, RoleIDAnnotationKey, iamRoleID)
	metav1.SetMetaDataAnnotation(&ctx.iamKey.ObjectMeta, "newKeyType", "true")
	log.Info("IAM Key created", "keyName", ctx.iamKey.Spec.ForProvider.KeyName)
	defer resp.Body.Close()
	return nil
}

func (p *IAMKeyPipeline) emitCreationEvent(ctx *pipelineContext) error {
	p.recorder.Event(ctx.iamKey, event.Event{
		Type:    event.TypeNormal,
		Reason:  "Created",
		Message: "IAMKey successfully created",
	})
	return nil
}

// createCredentialsSecret creates the secret with AIMKey's S3 credentials.
func (p *IAMKeyPipeline) createCredentialsSecret(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)
	secretRef := ctx.iamKey.Spec.WriteConnectionSecretToReference

	ctx.credentialsSecret = &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: secretRef.Name, Namespace: secretRef.Namespace}}

	_, err := controllerruntime.CreateOrUpdate(ctx, p.kube, ctx.credentialsSecret, func() error {
		secret := ctx.credentialsSecret
		secret.Labels = labels.Merge(secret.Labels, getCommonLabels(ctx.iamKey.Name))
		if secret.Data == nil {
			secret.Data = map[string][]byte{}
		}
		connDetails, err := toConnectionDetails(ctx.iamExoscaleKey)
		if err != nil {
			return fmt.Errorf("cannot parse connection details: %w", err)
		}
		for k, v := range connDetails {
			secret.Data[k] = v
		}
		secret.Immutable = pointer.Bool(true)

		err = controllerutil.SetOwnerReference(ctx.iamKey, secret, p.kube.Scheme())
		if err != nil {

			log.Error(err, "Cannot set owner reference")
			return err
		}
		return nil
	})
	if err != nil {
		log.Error(err, "Cannot create credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name), "secretData", ctx.credentialsSecret.Data, "secretLabels", ctx.credentialsSecret.Labels)
		return err
	}
	log.V(1).Info("Created credential secret", "secretName", fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
	return nil

}

func getCommonLabels(instanceName string) labels.Set {
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/
	return labels.Set{
		"app.kubernetes.io/instance":   instanceName,
		"app.kubernetes.io/managed-by": exoscalev1.Group,
		"app.kubernetes.io/created-by": fmt.Sprintf("controller-%s", strings.ToLower(exoscalev1.IAMKeyKind)),
	}
}
